/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package BaseGame;

import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;

import BaseGame.CardLogic.*;
import BaseGame.Cards.*;
import BaseGame.Rectangles.CardRectangle;
import BaseGame.Rectangles.Rectangle;
import processing.core.PApplet;
import processing.core.PImage;

public class App extends PApplet {

    public DeckHandler curGameHandler = new HomePage(this);
    private DeckHandler queuedGameHandler;
    public int numPlayers = 0;
    /** 0 for the host, -1 for an uninitialized player */
    public int thisPlayerNumber = -1;
    public int curPlayerNumber = 0;
    private int startingPlayerNumber = 0;
    public int minPlayerCount;
    private String hostName;

    /**
     * Float to multiply all widths and heights for differing resolutions based on a
     * default of 1920x1080 screen
     */
    public float scaleFactor;
    /** Default width of a card */
    public int defaultWidth; // = 100
    /** Default height of a card */
    public int defaultHeight; // = 145
    /** Default horizontal spacing for neighbor cards */
    public int defaultHSpacing; // = 15
    /** Default vertical spacing for selected cards */
    public int defaultVSpacing; // = 40

    public PImage imageList[];
    /** Index of the card back in imageList */
    public int cardBackIndex;

    public Player thisPlayer;
    public List<Player> playerList = new ArrayList<Player>();

    public DiscordBot bot;

    @Override
    public void settings() {
        fullScreen();
    }

    @Override
    public void setup() {
        background(0, 150, 0);
        frameRate(60);

        Rectangle.app = this;

        scaleFactor = min((float) displayWidth / 1920, (float) displayHeight / 1080);
        defaultWidth = (int) (100 * scaleFactor);
        defaultHeight = (int) (145 * scaleFactor);
        defaultHSpacing = (int) (15 * scaleFactor);
        defaultVSpacing = (int) (40 * scaleFactor);

        imageList = new PImage[13 * 4 + 3];
        for (Suit s : Suit.values()) {
            imageList[s.getValue()] = loadImage(
                    "app/src/main/resources/Poker Cards PNG/ace_of_" + s.toString() + ".png");

            for (int i = 1; i < 10; i++)
                imageList[i * 4 + s.getValue()] = loadImage(
                        "app/src/main/resources/Poker Cards PNG/" + (i + 1) + "_of_" + s.toString() + ".png");

            imageList[10 * 4 + s.getValue()] = loadImage(
                    "app/src/main/resources/Poker Cards PNG/jack_of_" + s.toString() + "2.png");
            imageList[11 * 4 + s.getValue()] = loadImage(
                    "app/src/main/resources/Poker Cards PNG/queen_of_" + s.toString() + "2.png");
            imageList[12 * 4 + s.getValue()] = loadImage(
                    "app/src/main/resources/Poker Cards PNG/king_of_" + s.toString() + "2.png");
        }
        cardBackIndex = 54;
        imageList[13 * 4 + 2] = loadImage("app/src/main/resources/Poker Cards PNG/card_back_red.png");
        imageList[13 * 4] = loadImage("app/src/main/resources/Poker Cards PNG/red_joker.png");
        imageList[13 * 4 + 1] = loadImage("app/src/main/resources/Poker Cards PNG/black_joker.png");
        try {
            String user = new String(Files.readAllBytes(Paths.get("misc/username.txt")), StandardCharsets.UTF_8).trim();
            DiscordBot.initializeBot(this, user);
        } catch (Exception e) {
            System.out.println("username.txt not found: Text file with your discord username only");
            exit();
            System.exit(1);
        }
    }

    public void hostGame(String host, String game) {
        thisPlayerNumber = 0;
        thisPlayer = new Player(host, numPlayers++);
        playerList.add(thisPlayer);
        queueGame(game, host);
        queuedGameHandler.initializeDeck();
        minPlayerCount = queuedGameHandler.minPlayerCount;
    }

    public boolean isHost(String host) {
        return host.equals(this.hostName);
    }

    public String getHost() {
        return hostName;
    }

    public void queueGame(String game, String host) {
        this.hostName = host;
        switch (game) {
            case "pontinho":
                queuedGameHandler = new PontinhoHandler(this);
                break;
            default:
                new Exception("Invalid game").printStackTrace();
                exit();
        }
    }

    public void addPlayer(String player) {
        playerList.add(new Player(player, numPlayers++));
    }

    public String getQueuedStartingDeck() {
        return queuedGameHandler.startingDeck;
    }

    public boolean waitingForGame() {
        return queuedGameHandler == null;
    }

    public void startGame(String startingDeck) {
        noLoop();
        draw();
        curGameHandler = queuedGameHandler;
        curGameHandler.initializeDeck(startingDeck);
        curGameHandler.setup();
        loop();
    }

    public CardRectangle pickedUpRect;
    public float xOffset;
    public float yOffset;

    @Override
    public void mouseClicked() {
        if (curGameHandler.handleMouseClick(mouseX, mouseY)) {
            bot.processMove(curGameHandler.encodeGameState());
        }
    }

    public boolean nextTurn() {
        return (curPlayerNumber = (curPlayerNumber + 1) % numPlayers) == thisPlayerNumber;
    }

    public void makeMove(String nextMove) {
        nextTurn();
        curGameHandler.nextTurn(nextMove);
    }

    /**
     * Picks up a rectangle to be moved if necessary
     */
    @Override
    public void mousePressed() {
        curGameHandler.handleMousePress(mouseX, mouseY);
    }

    @Override
    public void mouseReleased() {
        curGameHandler.handleMouseRelease(mouseX, mouseY);
    }

    @Override
    public void mouseDragged() {
        curGameHandler.handleMouseDrag(mouseX, mouseY);
    }

    @Override
    public void draw() {
        background(0, 150, 0);
        curGameHandler.draw();
    }

    public static void main(String[] args) {
        String PAppletArgs[] = { "--present" };
        PApplet.main("BaseGame.App", PAppletArgs);
    }

    public App() {
    }

    public App(int x) {
        surface = initSurface();
        sketchPath();
        handleDraw();
        setup();
        noLoop();
    }

    /**
     * Returns the list of the players in playerList split by {@code '\n'}
     * @return a String of the list of players split by {@code '\n'}
     */
    public String playerListToString() {
        String res = "";
        for (Player p : playerList) {
            res += p.toString() + "\n";
        }
        return res;
    }

    /**
     * Initializes the app's playerList with players given a {@link String} formatted
     * as in {@link BaseGame.App playerListToString}
     * @param stringList a String formatted as {@link BaseGame.App playerListToString}
     * @param user this player's name, used to initialize {@link thisPlayer} and {@link thisPlayerNumber}
     */
    public void makePlayerList(String stringList, String user) {
        String[] playerNames = stringList.split("\n");
        numPlayers = playerNames.length;
        for (int i = 0; i < numPlayers; i++) {
            String name = playerNames[i].substring(10);
            playerList.add(new Player(name, i));
            if (playerList.get(i).isPlayer(user)) {
                thisPlayerNumber = i;
                thisPlayer = playerList.get(i);
            }
        }
    }

    public boolean removePlayer(String name) {
        for (int i = 0; i < numPlayers; i++)
            if (playerList.get(i).isPlayer(name)) {
                playerList.remove(i);
                numPlayers--;
                return true;
            }
        return false;
    }

    public void reset() {
        // Stop loop completely to reassign all variables
        noLoop();
        draw();

        curGameHandler = new HomePage(this);
        queuedGameHandler = null;
        numPlayers = 0;
        thisPlayerNumber = -1;
        thisPlayer = null;
        playerList = new ArrayList<Player>();
        startingPlayerNumber = 0;
        loop();
    }

    public boolean roundOver() {
        return curGameHandler.winningPlayerNumber != -1;
    }

    public String initializeDeck() {
        return curGameHandler.initializeDeck();
    }

    public void nextRound(String initialDeck) {
        curGameHandler.initializeDeck(initialDeck);
        startingPlayerNumber = (startingPlayerNumber + 1) % numPlayers;
        curPlayerNumber = startingPlayerNumber;
        noLoop();
        draw();
        curGameHandler.setup();
        loop();
    }
}
